# Orbit Camera 명세

## 목적
카메라가 **한 점(타깃 T)**을 중심으로 도는 오빗. 사용자가 드래그할 때 “중심”이 움직이지 않아야 한다.

---

## 1. 전제

- **월드**: 오른손, Y 위. 타깃 `T = (tx, ty, tz)`.
- **카메라 눈 위치** `E`: 타깃에서 거리 `d`만큼 떨어진 점.  
  `E = T + d * u` (단, `u`는 단위 방향 벡터).
- **오빗 중 불변**: 드래그 동안 **T는 월드에서 고정**이며, **화면에서도 같은 픽셀에 고정**되어야 한다.  
  즉, 항상 “타깃 = 오빗의 중심 = 화면상 고정점”.

---

## 2. 수평 드래그 (deltaX만 있을 때)

- **의미**: 카메라가 타깃을 중심으로 “좌우”로 돈다.
- **회전축**: 타깃 T를 지나고, **월드 업과 평행**한 축.  
  즉 축 방향 = `(0, 1, 0)`.
- **회전**: 벡터 `(E - T)`를 이 축 기준으로 회전.  
  `offset' = R_Y(angle_h) * (E - T)`  
  드래그 오른쪽(deltaX > 0) → 카메라가 오른쪽으로 이동하도록 각도 부호 정의.
- **결과**: `E_new = T + offset'`.  
  T는 축 위에 있으므로 **수평 오빗의 중심 = T**.

---

## 3. 수직 드래그 (deltaY만 있을 때)

- **의미**: 카메라가 타깃을 중심으로 “위/아래”로 돈다.
- **회전축**: 타깃 T를 지나고, **현재 뷰의 “오른쪽”과 평행**한 축.  
  즉, **카메라 right 벡터**.  
  `forward = normalize(T - E)`,  
  `right = normalize(cross(worldUp, forward))`  
  (worldUp = (0,1,0)).
- **회전**: 벡터 `(E - T)`를 이 **right 축( T를 지나는 직선 )** 기준으로 회전.  
  `offset' = R_right(angle_v) * (E - T)`.  
  드래그 아래(deltaY > 0) → 카메라가 위로 올라가도록 각도 부호 정의.
- **결과**: `E_new = T + offset'`.  
  T는 right 축 위에 있으므로 **수직 오빗의 중심 = T**.

---

## 4. 수평+수직 동시 드래그 (deltaX, deltaY 둘 다)

- **요구사항**: 수평만 돌릴 때의 중심과 수직만 돌릴 때의 중심이 **같은 점 T**여야 함.  
  “옆으로 얼마나 움직였냐”에 따라 중심이 바뀌면 안 됨.
- **방법 1 (순차 적용)**  
  - 먼저 수평: `offset := R_Y(angle_h) * offset`.  
  - 그다음 수직: 이 시점의 `E = T + offset`으로 right 계산 후,  
    `offset := R_right(angle_v) * offset`.  
  - 두 회전 모두 **같은 벡터 (E - T)를 같은 점 T를 지나는 서로 다른 축**으로 회전하므로,  
    **항상 pivot = T**.
- **방법 2 (한 번에 한 회전)**  
  - 한 프레임에서 회전축 하나:  
    `axis = right * (-deltaY) + up * deltaX` (정규화).  
  - 각도: `angle = k * sqrt(deltaX^2 + deltaY^2)`.  
  - `offset' = R_axis(angle) * (E - T)`,  
    축은 T를 지나므로 역시 **pivot = T**.

---

## 5. 상태 저장 (theta, phi, distance)

- **정의**  
  - `offset = E - T` (길이 = distance, 방향 = u).  
  - `u = (cos(φ)sin(θ), sin(φ), cos(φ)cos(θ))`  
    → `theta = atan2(offset.x, offset.z)`,  
    `phi = asin(clamp(offset.y / distance, -1, 1))`,  
    `distance = |offset|`.
- **복원**  
  - 다음 프레임에서 `E = T + distance * u(θ, φ)` 로 계산.  
  - **T는 드래그로 바꾸지 않음** (팬은 별도 동작).

---

## 6. 뷰 행렬

- **계산**: `lookAt(eye, target, worldUp)`.  
  즉 시선 방향 = `target - eye`, 업 = 월드 업으로 잡아서 뷰를 만든다.
- **결과**: 타깃 T는 항상 뷰의 중심(프러스텀 중심)에 해당.  
  오빗만 할 때 T가 화면 한가운데에 고정되어야 함.

---

## 7. 코드와의 차이점 (검토 결과)

- **명세**: 수평 회전축 = **월드 업 (0,1,0)**. 수직 회전축 = **오프셋 (E−T)로부터 계산한 right** = `normalize(cross(worldUp, offset))`. 순차 적용 시 수직 축은 **수평 적용 직후의 offset**으로 계산.
- **코드 (현재)**: `getCameraBasis(cam)`의 right/up 사용. 이 basis는 **roll**을 반영하며, 오빗만 할 때는 roll=0이면 up=(0,1,0)이지만, **수직 축을 basis의 right로 쓰면** “화면 상의 오른쪽”이므로 명세와 일치.  
  **가능한 문제**: 아크볼에서 **각도**를 `k * sqrt(dx²+dy²)`로 한 번만 주면, 수평만/수직만 드래그할 때와 대각선 드래그할 때 **같은 픽셀 이동량에 대한 회전량**이 달라질 수 있음. 명세는 수평 각도 = k*deltaX, 수직 각도 = k*deltaY로 **분리**하는 것을 전제로 함.
- **수정 방향**: 명세대로 **순차 적용**(수평 → 수직), 수평축 = (0,1,0), 수직축 = **현재 offset으로부터 계산한 right** (getCameraBasis 미사용). 오빗 시 pivot은 항상 T.

---

## 8. 검증 체크리스트

- [ ] 수평만 드래그: 화면 중심에 있는 점(타깃)이 움직이지 않음.
- [ ] 수직만 드래그: 화면 중심에 있는 점(타깃)이 움직이지 않음.
- [ ] 수평으로 많이 돌린 뒤 수직 드래그: 여전히 같은 점(타깃)이 중심으로 고정.
- [ ] 수평/수직 동시 드래그: 한 프레임에 한 회전이든, 순차 두 회전이든 pivot은 항상 T.
- [ ] 상태 (theta, phi, distance)는 “T + offset”과 일치하고, T는 오빗 중 변경되지 않음.
